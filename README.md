# Problem-Solving Mastery

## 1. Problem-Solving Techniques

### 🧠 Brute Force
- **What it is**: Try all possible solutions and pick the best one.
- **When to use**: When the problem size is small or when you don't know a better approach.
- **Example**: Checking all possible combinations or permutations.

### 🏃 Greedy Algorithms
- **What it is**: Make the locally optimal choice at each step, aiming for a global optimum.
- **When to use**: When the problem has an "optimal substructure" and "greedy choice property."
- **Example**: Fractional knapsack problem, Huffman coding.

### ⚔️ Divide and Conquer
- **What it is**: Divide the problem into smaller subproblems, solve them independently, and combine their results.
- **When to use**: When the problem can be broken into independent subproblems.
- **Example**: Merge Sort, Quick Sort, Binary Search.

### 🧩 Dynamic Programming (DP)
- **What it is**: Solve problems by breaking them into smaller subproblems and storing solutions to avoid redundant work (memoization).
- **When to use**: When a problem has overlapping subproblems and optimal substructure.
- **Example**: Fibonacci sequence, 0/1 Knapsack problem, Longest Common Subsequence.

### 🕵️ Backtracking
- **What it is**: Try possible solutions step by step, but backtrack if you reach a solution that doesn't work.
- **When to use**: For problems that require exploring all possible configurations.
- **Example**: Solving N-Queens, Sudoku, and generating permutations.

### 🌐 Graph Algorithms
- **What it is**: Algorithms to process graphs, including traversal, shortest paths, and connectivity.
- **When to use**: When the problem involves nodes and edges.
- **Example**: BFS, DFS, Dijkstra's algorithm, A* Search.

### 🔢 Mathematical/Number Theory
- **What it is**: Apply mathematical principles to solve problems.
- **When to use**: For optimization or problems involving prime numbers, divisibility, or modular arithmetic.
- **Example**: Prime number sieve (Sieve of Eratosthenes), Euclidean algorithm for GCD.

---

## 2. Common Algorithms

### 🔄 Sorting Algorithms
- **Bubble Sort** – Simple but inefficient.
- **Quick Sort** – Efficient, but can have poor performance on some data.
- **Merge Sort** – Efficient with guaranteed O(n log n) performance.
- **Heap Sort** – Efficient for priority queue-like data.

### 🔍 Searching Algorithms
- **Binary Search** – Efficient searching in sorted arrays (O(log n)).
- **Linear Search** – Simple but inefficient for large unsorted arrays (O(n)).

### 📉 Dynamic Programming Algorithms
- **Knapsack Problem** – Find the most valuable set of items under a weight limit.
- **Longest Common Subsequence (LCS)** – Find the longest subsequence common to two sequences.
- **Edit Distance** – Minimum number of edits (insertions, deletions, substitutions) to convert one string into another.

### 🌐 Graph Algorithms
- **Depth First Search (DFS)** – Explore as deeply as possible before backtracking.
- **Breadth First Search (BFS)** – Explore all neighbors level by level.
- **Dijkstra's Algorithm** – Find the shortest path in a graph with weighted edges.
- **Floyd-Warshall** – All-pairs shortest path.
- **Kruskal's/Prim's Algorithm** – Minimum spanning tree (MST).

### 🔄 String Algorithms
- **Knuth-Morris-Pratt (KMP)** – Efficient string matching.
- **Rabin-Karp** – Pattern searching using hashing.
- **Z-Algorithm** – Pattern matching in linear time.

---

## 3. Most-Used Programming Languages

### 🖥️ Python
- **Why use it**: Simple syntax, rich libraries (NumPy, pandas, scikit-learn, etc.), fast prototyping, great for algorithm implementation and data science.
- **Commonly used for**: Competitive programming, algorithms, AI/ML, web development, data science.

### 👨‍💻 C++
- **Why use it**: High performance, extensive support for algorithmic problem solving, standard template library (STL) for data structures.
- **Commonly used for**: Competitive programming, systems programming, and performance-critical applications.

### 🌐 JavaScript
- **Why use it**: Widely used for web development (both frontend and backend with Node.js), large developer ecosystem, fast execution.
- **Commonly used for**: Web development, web apps, front-end, and server-side programming.

### ⚙️ Java
- **Why use it**: Strong object-oriented design, widely used in enterprise applications, stable and fast.
- **Commonly used for**: Backend development, Android app development, large-scale systems.

### 💾 C
- **Why use it**: Low-level programming, fast execution, control over system memory.
- **Commonly used for**: Systems programming, embedded systems, and high-performance applications.

### 🧑‍💻 Ruby
- **Why use it**: Elegant syntax, great for web apps, easy-to-write code.
- **Commonly used for**: Web development (Ruby on Rails), quick prototypes.

### ⚡ Go (Golang)
- **Why use it**: Fast, great for concurrency, simple syntax, high performance.
- **Commonly used for**: Systems programming, backend services, cloud-based applications.

---

## 4. Best Platforms for Practice

- **LeetCode** – Great for algorithmic challenges.
- **Codeforces** – Great for competitive programming contests.
- **HackerRank** – Offers a wide range of problems and competitions.
- **TopCoder** – One of the oldest platforms for competitive programming.
- **Exercism** – Code practice for multiple languages.
